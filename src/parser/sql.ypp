/*
 * Parser for mysql subset, GLR version
 */
%pure-parser
%parse-param { struct ParseResult* result}
%glr-parser
%expect 2
%expect-rr 57
%defines
%{
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <iostream>
#include <string>
#include <stdio.h>
#include <malloc.h>
#include <vector>
using namespace std;
#include "../astnode/ast_node.h"
#include "../astnode/ast_select_stmt.h"
#include "../astnode/ast_expr_node.h"
void yyerror(struct ParseResult *pp,const char *s, ...);
void emit(char *s, ...);
%}

%union {
	int intval;		
	double floatval;
	char* strval;
	int subtok;
	class AstNode * ast_node;
}
%{
#include "sql.lex.h"

#define YYLEX_PARAM result->yyscan_info_

/*
should replace YYLEX with the following clause in sql.tab.cpp, why so? I don't know

#ifdef YYLEX_PARAM
# define YYLEX yylex (&yylval, YYLEX_PARAM)
#else
# define YYLEX yylex (&yylval)
#endif
*/

%}
%token <strval> NAME
%token <strval> STRING
%token <strval> INTNUM
%token <strval> BOOL
%token <strval> APPROXNUM
%token <strval> USERVAR
/* operators and precedence levels */
%right ASSIGN
%left OR
%left XOR
%left ANDOP
%nonassoc IN IS LIKE REGEXP
%left NOT '!'
%left BETWEEN
%left <subtok> COMPARISON /* = <> < > <= >= <=> */
%left '|'
%left '&'
%left <subtok> SHIFT /* << >> */
%left '+' '-'
%left '*' '/' '%' MOD
%left '^'
%nonassoc UMINUS

%token ADD
%token ALL
%token ALTER
%token ANALYZE
%token AND
%token ANY
%token APPEND
%token AS
%token ASC
%token AUTO_INCREMENT
%token BEFORE
%token BETWEEN
%token BIGINT
%token BINARY
%token BIT
%token BLOB
%token BOTH
%token BY
%token CALL
%token CASCADE
%token CASE
%token CHANGE
%token CHAR
%token CHECK
%token COLLATE
%token COLUMN
%token COMMENT
%token CONDITION
%token CONSTRAINT
%token CONTINUE
%token CONVERT
%token CREATE
%token CROSS
%token CURRENT_DATE
%token CURRENT_TIME
%token CURRENT_TIMESTAMP
%token CURRENT_USER
%token CURSOR
%token DATABASE
%token DATABASES
%token DATE
%token DATETIME
%token DAY_HOUR
%token DAY  
%token DAY_MICROSECOND
%token DAY_MINUTE
%token DAY_SECOND
%token DECIMAL
%token DECLARE
%token DEFAULT
%token DELAYED
%token DELETE
%token DESC
%token DESCRIBE
%token DETERMINISTIC
%token DISTINCT
%token DISTINCTROW
%token DIV
%token DOUBLE
%token DROP
%token DUAL
%token EACH
%token ELSE
%token ELSEIF
%token ENCLOSED
%token END
%token ENUM
%token ESCAPED
%token EXISTS
%token EXIT
%token EXPLAIN
%token FETCH
%token FLOAT
%token FOR
%token FORCE
%token FOREIGN
%token FROM
%token FULLTEXT
%token GRANT
%token GROUP
%token HAVING
%token HIGH_PRIORITY
%token HOUR_MICROSECOND
%token HOUR_MINUTE
%token HOUR_SECOND
%token IF
%token IGNORE
%token IN
%token INDEX
%token INFILE
%token INNER
%token INOUT
%token INSENSITIVE
%token INSERT
%token INT
%token INTEGER
%token INTERVAL
%token INTO
%token ITERATE
%token JOIN
%token KEY
%token KEYS
%token KILL
%token LEADING
%token LEAVE
%token LEFT
%token LIKE
%token LIMIT
%token LINES
%token LOAD
%token LOCALTIME
%token LOCALTIMESTAMP
%token LOCK
%token LONG
%token LONGBLOB
%token LONGTEXT
%token LOOP
%token LOW_PRIORITY
%token MATCH
%token MEDIUMBLOB
%token MEDIUMINT
%token MEDIUMTEXT
%token MINUTE_MICROSECOND
%token MINUTE_SECOND
%token MOD
%token MODIFIES
%token NATURAL
%token NOT
%token NO_WRITE_TO_BINLOG
%token NULLX
%token NUMBER
%token ON
%token DUPLICATE
%token OPTIMIZE
%token OPTION
%token OPTIONALLY
%token OR
%token ORDER
%token OUT
%token OUTER
%token OUTFILE
%token PARTITIONED	
%token PRECISION	
%token PRIMARY
%token PROCEDURE
%token PROJECTION
%token PURGE
%token QUICK
%token QUARTER
%token READ
%token READS
%token REAL
%token REFERENCES
%token REGEXP
%token RELEASE
%token RENAME
%token REPEAT
%token REPLACE
%token REQUIRE
%token RESTRICT
%token RETURN
%token REVOKE
%token RIGHT
%token ROLLUP
%token SAMPLE
%token SCHEMA
%token SCHEMAS
%token SECOND_MICROSECOND
%token SELECT
%token SENSITIVE
%token SEPARATOR
%token SET
%token SHOW
%token SMALLINT
%token SOME
%token SONAME
%token SPATIAL
%token SPECIFIC
%token SQL
%token SQLEXCEPTION
%token SQLSTATE
%token SQLWARNING
%token SQL_BIG_RESULT
%token SQL_CALC_FOUND_ROWS
%token SQL_SMALL_RESULT
%token SSL
%token STARTING
%token STRAIGHT_JOIN
%token TABLE
%token TEMPORARY
%token TEXT
%token TERMINATED
%token THEN
%token TIME
%token TIMESTAMP
%token TINYBLOB
%token TINYINT
%token TINYTEXT
%token TO
%token TRAILING
%token TRIGGER
%token UNDO
%token UNION
%token UNIQUE
%token UNLOCK
%token UNSIGNED
%token UPDATE
%token USAGE
%token USE
%token USING
%token UTC_DATE
%token UTC_TIME
%token UTC_TIMESTAMP
%token VALUES
%token VARBINARY
%token VARCHAR
%token VARYING
%token WHEN
%token WHERE
%token WHILE
%token WITH
%token WRITE
%token XOR
%token YEAR
%token YEAR_MONTH
%token ZEROFILL
%token WEEK 

%token DO
%token MAX_QUERIES_PER_HOUR
%token MAX_UPDATES_PER_HOUR
%token MAX_CONNECTIONS_PER_HOUR
%token MAX_USER_CONNECTIONS
%token USER
%token TRUNCATE
%token FAST
%token MEDIUM
%token EXTENDED
%token CHANGED
%token LEAVES
%token MASTER
%token QUERY CACHE
%token SLAVE
%token BEGINT
%token COMMIT
%token START
%token TRANSACTION
%token NO
%token CHAIN
%token AUTOCOMMIT
%token SAVEPOINT
%token ROLLBACK
%token LOCAL
%token TABLES
%token ISOLATION
%token LEVEL
%token GLOBAL
%token SESSION
%token UNCOMMITTED
%token COMMITTED
%token REPEATABLE
%token SERIALIZABLE
%token IDENTIFIED
%token PASSWORD
%token PRIVILEGES
%token BACKUP
%token CHECKSUM
%token REPAIR
%token USE_FRM
%token RESTORE
%token CHARACTER
%token COLLATION
%token COLUMNS
%token ENGINE
%token LOGS
%token STATUS
%token STORAGE 
%token ENGINES
%token ERRORS
%token GRANTS
%token INNODB
%token PROCESSLIST
%token TRIGGERS
%token VARIABLES
%token WARNINGS
%token FLUSH
%token HOSTS
%token DES_KEY_FILE
%token USER_RESOURCES
%token CONNECTION
%token RESET
%token PREPARE
%token DEALLOCATE
%token EXECUTE
%token WORK
%token BTREE
%token HASH
%token BDB
%token OPEN
%token FULL

%token FSUBSTRING
%token FTRIM
%token FDATE_ADD FDATE_SUB
%token FCOUNT
%token FUPPER
%token FCAST
%token FCOALESCE
%token FCONVERT

%token FSUM
%token FAVG
%token FMIN
%token FMAX
  
%type <intval> select_opts opt_with_rollup opt_asc_desc opt_inner_cross left_or_right 
%type <intval> opt_left_or_right_outer opt_outer  
%type <ast_node> stmt_list  select_expr_list
%type <ast_node>  opt_where select_stmt stmt opt_groupby select_expr
%type <ast_node>  opt_having opt_orderby expr
%type <ast_node> groupby_list  table_reference table_factor orderby_list opt_limit
%type <ast_node> table_references opt_into_list opt_join_condition join_condition
%type <ast_node> column_list  table_subquery  join_table 
%type <ast_node> interval_exp
%type <ast_node> cast_data_type
%type <ast_node> expr_list opt_expr_list  case_list  
%type <strval>  opt_as_alias  trim_ltb


/*		// 2014-3-7---don't use this way to recovery from error---byYU
%destructor	{ if(result->error_number ) { puts("All node freed successfully!!"); FreeAllNode(result->node_pointerresult->node_pointer); } }<ast_node>
*/

%start stmt_list
%%

stmt_list: stmt ';'		
	{ 	
		printf("> \n"); 
		$$=new AstStmtList(AST_STMT_LIST,$1,NULL);
		if (result->error_number == 0) 
		{
			result->ast  = $$;
		}
		else
		{
			result->ast  = NULL;
		} 
  						
  	}	
	| stmt_list stmt ';'	
	{ 	
		printf(">> \n"); 
		$$=new AstStmtList(AST_STMT_LIST,$2,$1);
		if (result->error_number == 0)
		{
			result->ast  = $$;
		}
		else
		{
			result->ast  = NULL;
		}
	}		
  	| error ';'			
  	{ 
		printf(">> \n");
		result->ast  = NULL;	
		result->error_number++;	
		//yyerror(result,"First statement discarded, input new statement"); 
		yyclearin;
		yyerrok; 				
	}	
  	| stmt_list error ';'	
  	{ 
		printf(">> \n"); 
		result->ast  = NULL;	
		result->error_number++;		
		yyclearin;
		yyerrok; 
	}	
  	;

   /* statements: select statement */

stmt: select_stmt { $$ = $1;}		
	;

select_stmt: 
	SELECT select_opts select_expr_list
	{
		$$=new AstSelectStmt($2,$3,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
	}
	| SELECT select_opts select_expr_list FROM table_references opt_where 
    			opt_groupby opt_having opt_orderby opt_limit opt_into_list 
	{
		$$=new AstSelectStmt($2,$3,$5,$6,$7,$8,$9,$10,$11);
	}
	;

opt_where: 			{ $$ = NULL;}
	| WHERE expr	{ $$ = new AstWhereClause($2);}
	;

opt_groupby:									{ $$ = NULL;}
	| GROUP BY groupby_list opt_with_rollup 	{ $$ = new AstGroupByClause($3, $4);}
	;


groupby_list: 
	  expr 					{ $$=new AstGroupByList($1, NULL); }
	| expr ',' groupby_list { $$=new AstGroupByList($1, $3); };

opt_asc_desc:  	{ $$ = 0; }
   	| ASC      	{ $$ = 0; }
  	| DESC     	{ $$ = 1; }
    ;

opt_with_rollup:	{ $$ = 0; }
   	| WITH ROLLUP  	{ $$ = 1; }
   	;

opt_having:			{ $$=NULL; }
	| HAVING expr 	{ $$=new AstHavingClause($2);	}
	;

opt_orderby:					{ $$=NULL; }
	| ORDER BY orderby_list 	{ $$=new AstOrderByClause($3); }
	;
orderby_list:
	expr opt_asc_desc                   	{ $$=new AstOrderByList($1, $2, NULL);}
	| expr opt_asc_desc ',' orderby_list 	{ $$=new AstOrderByList($1, $2, $4); }
	;
opt_limit: 	 				{ $$ = NULL; }
	| LIMIT expr 			{ $$=new AstLimitClause(NULL,$2);}
  	| LIMIT expr ',' expr 	{ $$=new AstLimitClause($2,$4);}
  	; 

opt_into_list:			{ $$=NULL; }
   | INTO column_list 	{ $$=NULL;}
   ;

column_list: 
	NAME 					{ $$ = new AstColumn(string("NULL"), string($1));}
  	| NAME ',' column_list 	{ $$ = new AstColumn(string("NULL"), string($1), $3);}
  	;

select_opts:							{ $$ = 0; }
	| select_opts ALL					{ if($$ & 1) yyerror(result,"duplicate ALL option"); $$ = $1 | 1; }
	| select_opts DISTINCT				{ if($$ & 2) yyerror(result,"duplicate DISTINCT option"); $$ = $1 | 2; }
	| select_opts DISTINCTROW         	{ if($$ & 4) yyerror(result,"duplicate DISTINCTROW option"); $$ = $1 | 4; }
	| select_opts HIGH_PRIORITY       	{ if($$ & 8) yyerror(result,"duplicate HIGH_PRIORITY option"); $$ = $1 | 8; }
	| select_opts STRAIGHT_JOIN       	{ if($$ & 16) yyerror(result,"duplicate STRAIGHT_JOIN option"); $$ = $1 | 16; }
	| select_opts SQL_SMALL_RESULT    	{ if($$ & 32) yyerror(result,"duplicate SQL_SMALL_RESULT option"); $$ = $1 | 32; }
	| select_opts SQL_BIG_RESULT      	{ if($$ & 64) yyerror(result,"duplicate SQL_BIG_RESULT option"); $$ = $1 | 64; }
	| select_opts SQL_CALC_FOUND_ROWS 	{ if($$ & 128) yyerror(result,"duplicate SQL_CALC_FOUND_ROWS option"); $$ = $1 | 128; }
    ;

select_expr_list:
	select_expr							{ $$ = new AstSelectList(0,$1,NULL);}
    | select_expr ',' select_expr_list	{ $$ = new AstSelectList(0,$1,$3);}
    | '*'								{ $$ = new AstSelectList(1,NULL,NULL);}
    | '*' ',' select_expr_list			{ $$ = new AstSelectList(1,NULL,$3); }
    ;

select_expr: 
	expr opt_as_alias	{$$ = new AstSelectExpr(string($2),$1);}
	;

table_references: table_reference			{ $$ = new AstFromList($1,NULL); }
    | table_reference ',' table_references	{ $$ = new AstFromList($1,$3);}
    ;

table_reference:
	table_factor { $$=$1; }
  	| join_table { $$=$1; }
	;

table_factor:
	NAME opt_as_alias/* index_hint */
									{ $$ = new AstTable(string("NULL"),string($1),string($2));}
  	| NAME '.' NAME opt_as_alias /*index_hint*/ 
  									{ $$ = new AstTable(string($1),string($3),string($4)); }
  	| table_subquery opt_as NAME  	{ $$ = new AstSubquery(string($3),$1); }
	| '(' table_references ')' 		{ $$ = $2; }
  	;

opt_as:/* nil */ 
  | AS 
  ;

opt_as_alias: AS NAME { $$ = $2; }
  | NAME              { $$ = $1; }
  | /* nil */         { $$ = "NULL"; }
  ;

/*
inner 1
cross 2
outer 4
left 8
right 16
nature 32
straight_join -1
*/

join_table:
	table_reference opt_inner_cross JOIN table_factor opt_join_condition		{ $$ = new AstJoin($2, $1, $4, $5);}
	| table_reference STRAIGHT_JOIN table_factor 								{ $$ = new AstJoin(-1, $1, $3, NULL);}
	| table_reference STRAIGHT_JOIN table_factor ON expr  						{ $$ = new AstJoin(-1, $1, $3, $5);}
  	| table_reference left_or_right opt_outer JOIN table_factor join_condition	{ $$ = new AstJoin($2 + $3, $1, $5, $6);}
  	| table_reference NATURAL opt_left_or_right_outer JOIN table_factor			{ $$ = new AstJoin(32 + $3, $1, $5, NULL);}
  	;

opt_inner_cross: 	{ $$ = 0; }
   	| INNER			{ $$ = 1; }
   	| CROSS			{ $$ = 2; }
	;

opt_outer:			{ $$ = 4; }
	| OUTER			{ $$ = 4; }
   	;

left_or_right: 
	LEFT			{ $$ = 8; }
    | RIGHT 		{ $$ = 16; }
    ;

opt_left_or_right_outer:
	  LEFT opt_outer	{ $$ = 8 + $2; }
	| RIGHT opt_outer  	{ $$ = 16 + $2; }
	| /* nil */ 		{ $$ = 0; }
	;

opt_join_condition: 	{$$ = NULL;}
	| join_condition	{$$ = $1;}
	;
/*
on 1
using 2
*/

join_condition: 
	  ON expr 					{$$ = new AstJoinCondition("ON", $2); }
    | USING '(' column_list ')' {$$ = new AstJoinCondition("USING", $3); }
    ;


table_subquery: 
	'(' select_stmt ')' { $$=$2; }
   ;

/* statements: delete statement 1711 */


   /**** expressions ****/	
expr: NAME         { $$ = new AstColumn(string("NULL"),string($1));}
   | USERVAR       { $$ = new AstExprConst("CONST",string($1)); }
   | NAME '.' NAME { $$ = new AstColumn(string($1),string($3)); }
   | NAME '.' '*'  { $$ = new AstColumn(string($1),string("*"));}
   | STRING        { $$ = new AstExprConst("CONST_STRING",	string($1)); }
   | INTNUM        { $$ = new AstExprConst("CONST_INT",		string($1)); }	
   | APPROXNUM     { $$ = new AstExprConst("CONST_DOUBLE",	string($1)); }	
   | BOOL          { $$ = new AstExprConst("CONST_BOOL",	string($1)); }
   ;
expr: expr '+' expr 		                    { $$ = new AstExprCalBinary("+",   $1, $3); }
   | expr '-' expr 			                    { $$ = new AstExprCalBinary("-",   $1, $3); }
   | expr '*' expr 			                    { $$ = new AstExprCalBinary("*",   $1, $3); }
   | expr '/' expr 			                    { $$ = new AstExprCalBinary("/",   $1, $3); }
   | expr MOD expr                              { $$ = new AstExprCalBinary("MOD", $1, $3); }
   | expr '%' expr                              { $$ = new AstExprCalBinary("%",   $1, $3); }
   
   | '-' expr %prec UMINUS                      { $$ = new AstExprUnary("-", $2); }
   | '+' expr %prec UMINUS                      { $$ = new AstExprUnary("+", $2); }

   | expr ANDOP expr                            { $$ = new AstExprCalBinary("AND", $1, $3); }
   | expr OR expr                               { $$ = new AstExprCalBinary("OR",  $1, $3); }
   | expr XOR expr                              { $$ = new AstExprCalBinary("XOR", $1, $3); }

   | expr COMPARISON expr	                    { $$ = new AstExprCmpBinary("", 		$2, $1, $3); }
   | expr COMPARISON 	  '(' select_stmt ')'   { $$ = new AstExprCmpBinary("SUBQUERY", $2, $1, $4); }
   | expr COMPARISON ANY  '(' select_stmt ')'   { $$ = new AstExprCmpBinary("ANY",		$2, $1, $5); }
   | expr COMPARISON SOME '(' select_stmt ')'   { $$ = new AstExprCmpBinary("SOME",		$2, $1, $5); }
   | expr COMPARISON ALL  '(' select_stmt ')'   { $$ = new AstExprCmpBinary("ALL",		$2, $1, $5); }
   
   | expr '|' expr                              { $$ = new AstExprCalBinary("|",	$1, $3); }  
   | expr '&' expr                              { $$ = new AstExprCalBinary("&",	$1, $3); }  
   | expr '^' expr                              { $$ = new AstExprCalBinary("^",	$1, $3); }  
   | expr SHIFT expr                            { $$ = new AstExprCalBinary(SHIFT==1?"LSHIFT":"RSHIFT",$1,$3); }
   
   | '!' expr                                   { $$ = new AstExprUnary("!",	$2); }
   | NOT expr %dprec 1                          { $$ = new AstExprUnary("NOT",	$2); }
   | USERVAR ASSIGN expr	                    { $$ = NULL; }		
   | '(' expr ')'		                        { $$ = $2; }
   ;    

expr:  expr IS NULLX     						{ $$ = new AstExprUnary("IS_NULL", 		$1); }
   |   expr IS NOT NULLX 						{ $$ = new AstExprUnary("IS_NOT_NULL", 	$1); }
   |   expr IS BOOL      						{ $$ = new AstExprUnary("IS_BOOL", 		$1); }
   |   expr IS NOT BOOL  						{ $$ = new AstExprUnary("IS_NOT_BOOL", 	$1); }
   ;

expr:  expr BETWEEN expr AND expr %prec BETWEEN { $$ = new AstExprFunc("BETWEEN_AND", $1, $3, $5); }
   ;

expr_list: expr		             				{ $$ = new AstExprList($1, NULL);}
   | expr ',' expr_list          				{ $$ = new AstExprList($1, $3); }
   | '(' expr_list ')'	  	     				{ $$ = $2; }	
   ;

opt_expr_list:  expr_list        				{ $$ = new AstExprList($1, NULL); }  
   | expr_list ',' opt_expr_list 				{ $$ = new AstExprList($1, $3); }
   ;

expr: expr IN '(' expr_list ')'                 { $$ = new AstExprCmpBinary("EXPR_IN_LIST", 		$1, $4); }  
   |  '(' expr_list ')' IN '(' opt_expr_list ')'{ $$ = new AstExprCmpBinary("LIST_IN_LIST",			$2, $6); }
   |  expr NOT IN '(' expr_list ')'             { $$ = new AstExprCmpBinary("EXPR_NOT_IN_LIST", 	$1, $5); }
   | '(' expr_list ')' NOT IN  '(' expr_list ')'{ $$ = new AstExprCmpBinary("LIST_NOT_IN_LIST", 	$2, $7); }
   | expr IN '(' select_stmt ')'			    { $$ = new AstExprCmpBinary("EXPR_IN_SELECT", 		$1, $4); }
   | '(' expr_list ')' IN '(' select_stmt ')'	{ $$ = new AstExprCmpBinary("LIST_IN_SELECT", 		$2, $6); }
   | expr NOT IN '(' select_stmt ')'		    { $$ = new AstExprCmpBinary("EXPR_NOT_IN_SELECT", 	$1, $5); }
   |'(' expr_list ')' NOT IN '(' select_stmt ')'{ $$ = new AstExprCmpBinary("LIST_NOT_IN_SELECT", 	$2, $7); }
   
   | EXISTS '(' select_stmt ')'			        { $$ = new AstExprUnary("EXSIST", 		$3); }
   | NOT EXISTS '(' select_stmt ')'	%dprec 2	{ $$ = new AstExprUnary("NOT_EXSIST", 	$4); } 
   ;

  /* Is this used?
expr: NAME '(' opt_expr_list ')'	{ $$=newExprCal(t_expr_cal, "NAME", $1, 0, NULL, $3); }   
   ;
  */ 
  
  /* functions with special syntax */
  
expr: FCOUNT '(' '*' ')'	                    { $$ = new AstExprUnary("COUNT_ALL", NULL); }
    | FCOUNT '(' expr ')'	                    { $$ = new AstExprUnary("COUNT",	 $3); }
	| FSUM '(' expr ')'                         { $$ = new AstExprUnary("SUM",	 	 $3); }
	| FAVG '(' expr ')'                         { $$ = new AstExprUnary("AVG",	 	 $3); }
	| FMIN '(' expr ')'                         { $$ = new AstExprUnary("MIN",	 	 $3); }
	| FMAX '(' expr ')'                         { $$ = new AstExprUnary("MAX",	 	 $3); }
   
   ;
   
expr: FSUBSTRING '(' expr ',' expr ')'		    { $$ = new AstExprFunc("SUBSTRING_EXPR_EXPR", 				$3, $5, 	NULL); }
   | FSUBSTRING '(' expr FROM expr ')'		    { $$ = new AstExprFunc("SUBSTRING_EXPR_FROM_EXPR", 			$3, $5, 	NULL);}
   | FSUBSTRING '(' expr ',' expr ',' expr ')'  { $$ = new AstExprFunc("SUBSTRING_EXPR_EXPR_EXPR", 			$3, $5, 	$7); }
   | FSUBSTRING '(' expr FROM expr FOR expr ')' { $$ = new AstExprFunc("SUBSTRING_EXPR_FROM_EXPR_FOR_EXPR", $3, $5, 	$7); }
   | FTRIM '(' expr ')'						    { $$ = new AstExprFunc("TRIM_TRAILING", 					$3, NULL, 	NULL); }
   | FTRIM '(' trim_ltb expr FROM expr ')'	    { $$ = new AstExprFunc($3, 									$4, $6, 	NULL); }
   | FUPPER '(' expr ')'   					    { $$ = new AstExprFunc("UPPER", 							$3, NULL,	NULL); }
   | FCAST '(' expr AS cast_data_type ')'       { $$ = new AstExprFunc("CAST",								$3, $5,  	NULL); }
   | FCOALESCE '(' expr_list ')'                { $$ = new AstExprFunc("COALESCE", 							$3, NULL, 	NULL); }
   ;
 
trim_ltb: LEADING   { $$="TRIM_LEADING"; }
   | TRAILING 		{ $$="TRIM_TRAILING"; }
   | BOTH 			{ $$="TRIM_BOTH"; }
   ;
   
cast_data_type:	{ $$ = NULL;}  
   | INTEGER   {$$ = new AstExprConst("INT", 	NULL);}
   | STRING    {$$ = new AstExprConst("STRING", NULL);}
   | DOUBLE    {$$ = new AstExprConst("DOUBLE", NULL);}
   | FLOAT     {$$ = new AstExprConst("FLOAT", 	NULL);}
   | CHAR      {$$ = new AstExprConst("CHAR", 	NULL);}
   ;
   
expr: FDATE_ADD '(' expr ',' interval_exp ')'   { $$ = new AstExprFunc("DATE_ADD", $3, $5, NULL); }
   |  FDATE_SUB '(' expr ',' interval_exp ')'   { $$ = new AstExprFunc("DATE_SUB", $3, $5, NULL); }
   ;
   
interval_exp: 
    INTERVAL expr DAY_HOUR         	            { $$ = new AstExprFunc("INTERVAL_HOUR", 		$2, NULL, NULL);  }
   | INTERVAL expr DAY_MICROSECOND              { $$ = new AstExprFunc("INTERVAL_MICROSECOND", 	$2, NULL, NULL);  }
   | INTERVAL expr DAY_MINUTE                   { $$ = new AstExprFunc("INTERVAL_MINUTE", 		$2, NULL, NULL);  }
   | INTERVAL expr DAY_SECOND                   { $$ = new AstExprFunc("INTERVAL_SECOND", 		$2, NULL, NULL);  }
   | INTERVAL expr DAY                          { $$ = new AstExprFunc("INTERVAL_DAY", 			$2, NULL, NULL);  }
   | INTERVAL expr YEAR_MONTH                   { $$ = new AstExprFunc("INTERVAL_MONTH", 		$2, NULL, NULL);  }
   | INTERVAL expr YEAR                         { $$ = new AstExprFunc("INTERVAL_YEAR", 		$2, NULL, NULL);  }
   | INTERVAL expr WEEK                         { $$ = new AstExprFunc("INTERVAL_WEEK", 		$2, NULL, NULL);  }
   | INTERVAL expr QUARTER                      { $$ = new AstExprFunc("INTERVAL_QUARTER", 		$2, NULL, NULL);  }
   ;   
   
	
expr: CASE expr case_list END			        { $$ = new AstExprFunc("CASE1", 		$2, 	$3, NULL); }
   |  CASE expr case_list ELSE expr END	        { $$ = new AstExprFunc("CASE1_ELSE", 	$2, 	$3, $5); }   
   |  CASE case_list END                        { $$ = new AstExprFunc("CASE2", 		NULL,	$2, NULL); }
   |  CASE case_list ELSE expr END              { $$ = new AstExprFunc("CASE2_ELSE", 	NULL, 	$2, $4); }
   ;

case_list: WHEN expr THEN expr                  { $$ = new AstExprFunc("WHEN", $2, $4, NULL); }
   | case_list WHEN expr THEN expr	            { $$ = new AstExprFunc("WHEN", $3, $5, $1); }
   ;

expr: expr LIKE expr	                        { $$ = new AstExprCalBinary("LIKE", 	$1, $3); }
   | expr NOT LIKE expr                         { $$ = new AstExprCalBinary("NOT_LIKE", $1, $4); }
   ;

expr: expr REGEXP expr		                    { $$ = new AstExprCalBinary("REGEXP", 		$1, $3); }
   | expr NOT REGEXP expr	                    { $$ = new AstExprCalBinary("NOT_REGEXP", 	$1, $4); }
   ;


%%

void emit(char *s, ...)
{
 	/* 
 	extern int yylineno;
	va_list ap;
  	va_start(ap, s);
  	printf("rpn: ");
  	vfprintf(stdout, s, ap);
  	printf("\n");
  	*/
}

void yyerror(struct ParseResult *pp,const char *  s, ...)
{
	/*  
	va_list ap;
	va_start(ap, s);	
	fprintf(stderr, "%d: error: ", yyget_lineno(pp->yyscan_info_));
	vfprintf(stderr, s, ap);
	fprintf(stderr, "\n");
	*/
	fprintf (stderr, "%s\n", s);
}
